CoreASM TerminationDetection

use Standard
use StandardPlugins
use Signature
use MathPlugin

enum COLOR = {black, white}
enum TOKEN = {blackToken, whiteToken}
enum STATUS = {active, passive}
enum MACHINE = {m0, m1, m2,m3, m4, m5, m6, m7} 
enum COMPUTATION = {c1, c2,c3}
universe Agents = {protocol, activation, p, supervisor}
function color: MACHINE * COMPUTATION -> COLOR
function token: MACHINE * COMPUTATION -> TOKEN
//function static Next: MACHINE -> MACHINE
function status: MACHINE * COMPUTATION -> STATUS
                
init InitRule

rule InitRule = 
	par
		forall c in COMPUTATION do{
			forall m in MACHINE do{
				color(m,c) := white
				
				if random() > 0.5 then status(m,c) := passive else status(m,c) := active
				if m = m0 then		
					token(m,c) := blackToken 
				else token(m,c) := undef
			}
		}
		//initilize agents
			program(protocol) := @RunStimulation
			program(supervisor) := @RunSupervisor
			program(activation) := @ChangeStatus
			program(p) := @makePassive
			
    		Agents(self) := false
	endpar

rule ForwardToken(t, m, c) = { 
		print "token: " + t + " machine: " + m + " computation: " + c
		if m = m0 then token(m1, c) := t
		if m = m1 then token(m2, c) := t 
		if m = m2 then token(m3, c) := t 
		if m = m3 then token(m4, c) := t
		if m = m4 then token(m5, c) := t 
		if m = m5 then token(m6, c) := t 
		if m = m6 then token(m7, c) := t 
		if m = m7 then token(m0, c) := t 
}

rule RunStimulation = { 
	forall m in MACHINE do 
		if m != m0 then
			forall c in COMPUTATION do
				RegularMachineProgram(m,c)

}
rule RunSupervisor = { 
	forall c in COMPUTATION do
		SupervisorMachineProgram(m0, c)
}
rule InitializeToken(m, c)= {
	token(m,c) := undef
	color(m,c) := white
}

rule RegularMachineProgram(m,c) ={

	if status(m,c) = passive and token(m,c) != undef then
	{
		seq
			if color(m,c) = black then
			{	
				print "regularMachine: color= " + color(m,c) + " status= " +status(m,c) + " token= " + token(m,c) + " machine: " + m + " computation: " + c   	
				ForwardToken(blackToken, m, c)
				if token(m,c) = whiteToken then color(m,c) := white
			}
			else
			{
				print "regularMachine: color= " + color(m,c) + " status= " +status(m,c) + " token= " + token(m,c) + " machine: " + m + " computation: " + c   	
				ForwardToken(token(m,c), m, c)
			}
 			InitializeToken(m,c)
	}
}

rule SendMessage(m,c) = {
	if status(m, c) = active then
		color(m, c) := black
		choose receiver in MACHINE do
			status(receiver, c) := active 
	print "message sent"
}

rule SupervisorMachineProgram(m,c) ={

	if status(m,c) = passive and token(m,c) != undef then
	{	
		if color(m,c) = white and token(m,c) = whiteToken then{	
			token(m,c) := undef
			if token(m,c1) = undef and token(m,c2) = undef and token(m,c3) = undef then
				ReportGlobalTermination(c)
		}
		else 
		{
			seq
				print "supervisorMachine: color= " + color(m,c) + " status= " +status(m,c) + " token= " + token(m,c) + " machine: " + m
				ForwardToken(whiteToken, m, c)
				InitializeToken(m,c)
		}
	}
} 
    	
rule ChangeStatus ={
	choose m in MACHINE do 
		choose c in COMPUTATION do
			if random() > 0.75 then SendMessage(m,c)
}
	
rule makePassive ={
	print "makepassive"
	choose m in MACHINE do
		choose c in COMPUTATION do
			status(m,c) := passive
}
rule ReportGlobalTermination(c) =
{
		print c + " terminated"
		program(self) := undef
		program(protocol) := undef
		program(supervisor) := undef
		program(activation) := undef
		program(p) := undef

}

