CoreASM TerminationDetection

use Standard
use StandardPlugins
use Signature
use MathPlugin

enum COLOR = {black, white}
enum TOKEN = {blackToken, whiteToken}
enum STATUS = {active, passive}
enum MACHINE = {m0, m1, m2} 
enum COMPUTATION = {c1}
universe Agents = {protocol, activation, p}
function color: MACHINE * COMPUTATION -> COLOR
function token: MACHINE * COMPUTATION -> TOKEN
function static Next: MACHINE -> MACHINE
function status: MACHINE * COMPUTATION -> STATUS
                
init InitRule

rule InitRule = 
	par
		forall c in COMPUTATION do{
			forall m in MACHINE do{
				color(m,c) := white
				status(m,c) := passive
				if m = m0 then		
					token(m,c) := blackToken 
				else token(m,c) := undef
			}
		}
		//initilize agents
			program(protocol) := @RunStimulation
			program(activation) := @ChangeStatus
			program(p) := @makePassive
			
    		Agents(self) := false
	endpar

rule ForwardToken(t, m, i) = {
	token(Next(m), i) := t
}

rule RunStimulation = { 
	forall m in MACHINE do 
		forall c in COMPUTATION do
			if m = m0 then SupervisorMachineProgram(m,c) else RegularMachineProgram(m,c)

}
rule InitializeToken(m, c)= {
	token(m,c) := undef
	color(m,c) := white
}

rule RegularMachineProgram(m,c) ={
	print "machine: " + m
	print "next: " + Next(m)
		
	print "regularMachine: color= " + color(m,c) + " status= " +status(m,c) + " token= " + token(m,c)  	
	if status(m,c) = passive and token(m,c) != undef then
	{
		if color(m,c) = black then	
			ForwardToken(blackToken, Next(m), c)
			if token(m,c) = whiteToken then color(m,c) := white
		else	
			ForwardToken(token(m,i), Next(m), c)
 		InitializeToken(m,c)
	}

}

rule SendMessage(m,c) = {
	if status(m, c) = active then
		color(m, c) := black
		choose receiver in MACHINE do
			status(receiver, c) := active 
}

rule SupervisorMachineProgram(m,c) ={
	print "supervisorMachine: color= " + color(m,c) + " status= " +status(m,c) + " token= " + token(m,c)  	
	if status(m,c) = passive and token(m,c) != undef then
	{	
		if color(m,c) = white and token(m,c) = white then	
			ReportGlobalTermination
		else 
		{
			ForwardToken(whiteToken, Next(m), i)
			InitializeToken(m,c)
		}
	}
} 
    	
rule ChangeStatus ={
	choose m in MACHINE do 
		choose c in COMPUTATION do
			if random() > 0.75 then SendMessage(m,c)
		
}
	
rule makePassive ={
	print "makepassive"
	choose m in MACHINE do
		choose c in COMPUTATION do
			status(m,c) := passive
}
rule ReportGlobalTermination =
{
		print "terminated"
		program(self) := undef
}
