CoreASM TerminationDetection

use Standard
use StandardPlugins
use Signature

enum COLOR = {black, white}
enum TOKEN = {blackToken, whiteToken}
enum STATUS = {active, passive}
enum MACHINE = {m0, m1, m2, m3} 
enum COMPUTATION = {c1, c2, c3}

function color: MACHINE * COMPUTATION -> COLOR
function token: MACHINE * COMPUTATION -> TOKEN
function static Next: MACHINE -> MACHINE
function status: MACHINE * COMPUTATION -> STATUS
function monitored BlackTokenEvent: MACHINE * COMPUTATION-> BOOLEAN
function monitored WhiteTokenEvent: MACHINE * COMPUTATION -> BOOLEAN
function monitored SendMessageEvent: MACHINE * COMPUTATION -> BOOLEAN            
                
init InitRule

rule InitRule = 
	par
    		extend Agents with controller do
			program(controller) := @InitializeMachine
    		Agents(self) := false
	endpar

rule InitializeMachine = 
	par
		forall m in MACHINE do{
			forall c in COMPUTATION do{
				token(m,i) := undef	
				color(m,i) := white
				RegularMachineProgram(m,i)
				SupervisorMachineProgram(m,i)
			}
		}
	endpar

rule ReactOnEvents(m, i) = {
	if BlackTokenEvent(m, i) then
		token(m,i) := blackToken
	if WhiteTokenEvent(m, i) then	
		token(m, i) := whiteToken
	if SendMessageEvent(m,i) then
		color(m,i) := black
	print color(m,i)
	print token(m,i)
}

rule ForwardToken(token, m, i) = {
	token(Next(m), i) := token
	print token	
	print m
	print i
}

rule RegularMachineProgram(m, i) = { 
	ReactOnEvents(m, i)
	if status(m, i) = passive and token(m, i) != undef then
		if color(m, i) = black then
				ForwardToken(blackToken, Next(m), i)
		else
				ForwardToken(token(m, i), Next(m), i)
}

rule SupervisorMachineProgram(m,i) = {
    ReactOnEvents(m, i)
    if m = m0 then
    	if status(m, i) = passive and token(m, i) != undef then
        	if color(m, i) = white and token(m, i) = whiteToken then
            		ReportGlobalTermination
        	else
            		ForwardToken(whiteToken, Next(m)) 
}

rule ReportGlobalTermination =
		print "terminated"


