CoreASM TerminationDetection

use Standard
use StandardPlugins
use Signature

enum COLOR = {black, white}
enum TOKEN = {blackToken, whiteToken}
enum STATUS = {active, passive}
enum MACHINE = {m1, m2, m3} 
enum COMPUTATION = {c1, c2, c3}
//universe Agents = {eventReactor, regularController}

function color: MACHINE * COMPUTATION -> COLOR
function token: MACHINE * COMPUTATION -> TOKEN
function static Next: MACHINE -> MACHINE
function status: MACHINE * COMPUTATION -> STATUS
function monitored BlackTokenEvent: MACHINE * COMPUTATION-> BOOLEAN
function monitored WhiteTokenEvent: MACHINE * COMPUTATION -> BOOLEAN
function monitored SendMessageEvent: MACHINE * COMPUTATION -> BOOLEAN            
                
init InitRule

rule InitRule = 
	par
    		extend Agents with controller do
			program(controller) := @InitializeMachine
    		Agents(self) := false
	endpar

rule InitializeMachine = 
	par
		forall m in MACHINE do{
			forall c in COMPUTATION do{
				token(m,i) := undef	
				color(m,i) := white
				RegularMachineProgram(m,i)
			}
		}
	endpar

rule MainProgram = {
	 extend MACHINE with m do
    		extend COMPUTATION with c do
    			program(regularController) := @RegularMachineProgram
}

rule ReactOnEvents(m, i) = {
	if BlackTokenEvent(m, i) then
		token(m,i) := blackToken
	if WhiteTokenEvent(m, i) then	
		token(m, i) := whiteToken
	if SendMessageEvent(m,i) then
		color(m,i) := black
}

rule ForwardToken(token, m, i) = {
	token(Next(m), i) := token
}

rule RegularMachineProgram(m, i) = { 
	print "Hello World!"
	ReactOnEvents(m, i)
	if status(m, i) = passive and token(m, i) != undef then
		//InitializeMachine(m, i) 
		if color(m, i) = black then
			ForwardToken(blackToken, Next(m), i)
		else
			ForwardToken(token(m, i), Next(m), i)
	//		InitializeMachine(m, i)
}

rule SupervisorMachineProgram = {
    ReactOnEvents(m, i)
    if status(m, i) = passive and token(m, i) != undef then
        if color(m, i) = white and token(m, i) = whiteToken then
            ReportGlobalTermination
        else
            InitializeMachine(m, i)
            ForwardToken(whiteToken, Next(m)) 
}



